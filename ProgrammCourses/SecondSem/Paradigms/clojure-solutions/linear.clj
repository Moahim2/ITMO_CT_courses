(defn abstractOperation [absOp] (fn [x, y] (cond
                                             (vector? x) (mapv (abstractOperation absOp) x y)
                                             :else (absOp x y))))
(def v+ (abstractOperation +))
(def v- (abstractOperation -))
(def v* (abstractOperation *))
(def vd (abstractOperation /))
(defn v*s [u1 s]  (mapv #(* s %) u1))
(defn scalar [u1 u2] (apply + (v* u1 u2)))
(defn vectImpl [i j u1 u2] (- (* (nth u1 i) (nth u2 j)) (* (nth u1 j) (nth u2 i))))
(defn vect [u1, u2] (vector (vectImpl 1 2 u1 u2) (vectImpl 2 0 u1 u2) (vectImpl 0 1 u1 u2)))
(def m+ v+)
(def m- v-)
(def m* v*)
(def md vd)
(defn m*s [m s] (mapv #(v*s % s) m))
(defn transpose [m] (mapv (fn[i] (mapv #(nth % i) m)) (range (count (first m)))))
(defn m*v [m v] (mapv #(apply + (v* % v)) m))
(defn m*m [m1 m2] (transpose (mapv #(m*v m1 %) (transpose m2))))
(def s+ v+)
(def s- v-)
(def s* v*)
(def sd vd)