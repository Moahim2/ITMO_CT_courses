# Лекция 6(a): Работа с памятью

Представим, что мы хотим написать бинарное дерево. У каждой вершины есть не более одного ребенка, являющихся такими же вершинами. Создадим класс Node. Как задать детей?  

Приведенный ниже вариант **не является** корректным, так как нельзя в объявлении класса использовать его же:

``` C++
struct Node { // некорректный пример
    Node left;
    Node right;
}
```

Можно попробовать использовать ссылки, но тогда нельзя будет не иметь какого-то ребенка, так как для создания ссылки нужен объект.

На помощь приходят указатели. Они обладают всеми необходимыми для данного примера свойствами:

``` C++
struct Node {
    Node* left = nullptr;
    Node* right = nullptr;
}
```

## Массивы
``` C++
int a[5]; // создание массива на 5 элементов типа int
int a[5] = {1, 2, 3, 4, 5}; // инициализация массива 5 значениями
int a[] = {1, 2, 3}; // инициализация массива 3 значениями

char str[] = "Hello";
size_t size = sizeof(str) / sizeof(str[0]); // размер массива str
std::cout << size; // 6, тк в конце еще есть символ '\0' для обозначения конца строки

int c[2][3] = {{1,2,3},{4,5,6}}; // инициализация двумерного массива
```

Массив не может быть возвращаемым значением.  
Помимо этого массив нельзя передать по значению.  

Как передать массив по ссылке?

``` C++
void f(int (&a) [5]) {
    std::cout << sizeof(a) << "\n";
}

int main() {
    int x[5];
    f(x); // выведет 20
}
```

## Указатели
Указатели - абстракция над адресами в памяти.  
Они являются единственным способом динамического выделения памяти в C++.

Примеры объявлений:
``` C++
int * a;
const int *** b;
const double * c;
```
Размер указателя равен размеру машинного слова (в 64-разрядных системах 8 байт).  
(Не все так однозначно когда мы говорим про указатели на функции)  
Можно менять, куда указывает указатель.

Пример кода:
``` C++
int a = 8;
int b = 9;
int * pa = &a; // & является оператором взятия адреса
int * pb = &b; 
std::cout << pa; // адрес переменной a, например 0x16da536fc
std::cout << *pa; // значение переменной a, 8
std::cout << pb; // адрес переменной b, например 0x16da536f8
pb = &a; // теперь pb указывает на a
std::cout << pb; // 0x16da536fc
```

Указатель может указывать на функцию:
``` C++
void f(int val) {
    std::cout << val;
}

int main() {
    void (*pf) (int) = f;
	(*pf)(10); // так можем вызвать функцию, получим 10
	pf(10); // так тоже можем вызвать функцию, получим 10
}
```
Массив может неявно приводиться к указателю на его первый элемент:
``` C++
int a[5];
int *pa = a; <-> int *pa = &a[0];
```
Нельзя создать массив ссылок или массив функций, но можно создать массив указателей.

Обращаться к полям объекта через указатель можно следующим образом:
``` C++
struct S {
    int a = 0;
    char b;
};

int main() {
    S * s = new S();
    s->a++; <-> (*s).a++; // такая запись эквивалентна
    std::cout << s->a; // 1
}
```
Нулевые указатели:
```C++
nullptr // Литерал, имеющий тип std::nullptr_t
        // Неявно приводится к нулевому указателю любого типа

NULL // Является макросом который равен целому числу 0. Лучше использовать nullptr тк
     // работает неявное приведение типов целого числа к значению указателя -> можно запутаться

std::nullptr_t // Тип данных который может иметь только одно значение - nullptr.
               // Может понадобиться если хотим чтобы функция принимала nullptr
               
int * a = nullptr;
std::cout << std::boolalpha << (a == nullptr); // true
```

Резюме по ссылкам:
* Ссылки иммутабельны  
* Ссылки не являются объектами  
* Ссылка не может иметь нулевое значение

Пример того как писать нельзя:
``` C++
void f(int * a) { // указатель может быть равен null -> стоит написать if-else
  std::cout << *a << std::endl;
}
```

Примеры кода с указателями:
``` C++
int ** a; // указатель на указатель на int

const int * const b = nullptr; // в отличие от ссылки можно const в нескольких местах писать

// Для удобства можно писать const справа от того, к чему он относится:
int const * const c = nullptr; // (int const) (* const) a = nullptr;

int const * d; // указатель на const int
++(*d);        // ошибка
++d;           // можно

int const * const d; // const указатель на const int
++(*d);              // ошибка
++d;                 // ошибка

int * const d; // const указатель на int
++(*d);        // можно
++d;           // ошибка

int const * const * const * const x; // пример почему const лучше писать справа
                                     // Но если нет подобных конструкций, то принято писать слева
```
Указатели одного типа можно сравнивать.  
Значения указателей равны, если они указывают на один и тот же объект или оба нулевые.

Язык гарантирует:
``` C++
int a[10];
std::cout << std::boolalpha << (&a[3] < &a[8]); // true
std::cout << std::boolalpha << (&a[6] < &a[3]); // false
```

С элементом после массива сравнение тоже работает, но его разыменовывание - UB.  
Любые другие сравнения указателей - подробности реализации.

Но существует std::less, который гарантирует работу следующего кода:
``` C++
int a, b;
std::less<int *> cmp; 
std::cout << std::boolalpha << cmp(&a, &b); 
```
Существует бестиповый указатель, к которому неявно приводятся любые другие указатели. Обратное приведение может быть только явным:
```C++
int a;
void * pv = &a; 
int * b = static_cast<int *>(pv);
```
Это правильно работает, если мы возвращаем к первоначальному типу. Иначе будет UB. Однако можно использовать reinterpret_cast, в некоторых случаях может быть полезен, но на него существует много ограничений.

## Арифметика указателей
Как можно вывести все элементы массива?
``` C++
int a[5] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i++) {
    std::cout << a[i] << " ";
}
```
Язык C++ позволяет выполнять целочисленные операции сложения/вычитания с указателями.  
Так как элементы массива расположены в памяти последовательно, мы можем проитерироваться по массиву подобным образом:
``` C++
int a[5] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i++) {
    std::cout << *(a + i) << " ";
}
```
Либо так:
``` C++
int a[5] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i++) {
    std::cout << i[a] << " ";
}
```