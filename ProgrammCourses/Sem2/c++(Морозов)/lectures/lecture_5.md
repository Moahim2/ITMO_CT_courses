# Лекция 5: Специальные методы классов, копирование и перемещение

Чтобы передать в функцию объект, не копируя его, используем передачу по ссылке:
```C++
Rational operator + (const int lhs, const Rational & rhs) {...}
``` 

Возвращать объект из функции можно тоже по ссылке. Это имеет смысл, если возвращаемый объект создан где-то за пределами. Если объект локальный, то после завершения исполнения функции объект разрушится, и возвращаемая ссылка будет указывать на некорректное место, а это `UB`.
```C++
Rational & operator ++ ()
{
  ...
  return *this;
}
```

Вот так можно создать ссылку:
```C++
int a = 10;
int & b = a;
b++; // теперь можем пользоваться ей как обычной переменной, и менять через нее значение в a
```

Ссылку нельзя создать без объекта, на который она будет ссылаться. Ее нельзя переназначить.

```C++
сonst int & b = a; // через такую ссылку нельзя изменить объект a
```

Если пометить ссылку константной - не значит что объект будет константный, сам объект `a` менять можно, нельзя через ссылку `b`.  
А если сам объект `a` сделать константным, то его в целом менять нельзя.

С помощью `const_cast` можно снять константность со ссылки (из константной ссылки получить неконстантную).  
Если объект, на который указывала константная ссылка, сам не был объявлен константным, тогда такое преобразование является легальным (хотя и очень редко когда осмысленным - без особой нужды не следует снимать константность).  
Если объект был объявлен константным, то любая попытка его модификации - UB.


`const` можно писать слева от типа или справа, разницы нет.

```C++
int const a = 0, b = 1; // обе const int
```
Можем сделать псевдоним типа:
```C++
using T = const int; // псведоним типа
T a = 0, b = 1;
```

Какие еще бывают типы ссылок?  
* `lvalue -> &`
* `rvalue -> &&`

В чем между ними разница?

|                 | Временные объекты | Постоянные объекты |
|-----------------|-------------------|--------------------|
|lvalue ref       | -                 | +                  |
|const lvalue ref | +                 | +                  |
|rvalue ref       | +                 | -                  |
|const rvalue ref | +                 | -                  |

Можно привести `lvalue` ссылку к `rvalue` ссылке с помощью `std::move` и, таким образом, получить `rvalue` ссылку на постоянный объект.

Rvalue ссылки были специально созданы для того, чтобы ссылаться на временные объекты с возможностью их изменения. `const rvalue` ссылка имеет смысл только для симметрии.

Существуют тонкости с тем, что является временным объектом, чье время жизни можем продлить. Если вернуть из функции ссылку на локальный объект (локальная переменная или объект, созданный после слова `return`), его время жизни не продлится, и даже присвоив результат `rvalue` ссылке, ссылка будет 'висячей'.

Второй характерный случай непродления:  
```C++
X & f(X & x)
{
    return x;
}

X g();

void foo()
{
    X & x = f(g()); // x является висячей ссылкой
}
```

**Вернемся к `Rational`:**

Агрегатная инициализация `Rational r{1, 2}` работает только для классов с публичными полями, так как эта инициализация просто заменяет обращение к полям через точку.

Что же делать? Ведь приватность полей это необходимость.  
Для этого используется конструктор.  
Это специальная функция-член, которая имеет то же имя, что и тип нашего класса, принимает аргументы, не имеет возвращаемого значения.  
В одном классе может быть много конструкторов.

Вызов конструктора:
```C++
Rational a(0, 1);
```

Поля класса могут быть заданы с помощью списка инициализации:
```C++
Rational(const int a, const int b) : numerator(a), denominator(b) {} // список инициализации
```
В теле конструктора можно писать код, обращаться к полям класса. Поэтому инициализировать поля можно было бы и в теле конструктора.

**Почему список инициализации лучше?**  
Для базовых типов проблемы нет, но если полем является объект, то для него сначала произойдет инициализация по умолчанию, а потом инициализация, записанная в теле конструктора. А если написать его инициализацию в списке инициализации, она произойдет один раз.

Если класс `Y` наследуется от класса `X`, и в `X` нет конструктора по умолчанию, то если в конструкторе `Y` ничего не написать, будет ошибка. Поэтому нужно явно вызвать конструктор `X`, который у него есть:
```C++
Y(const int x) : X(x)
{
}
```

Если у конструктора убрать список инициализации, то будет выполнена инициализация по умолчанию, и к моменту выполнения тела конструктора поля будут иметь эти значения:
```C++
int numerator   = 0;
int denominator = 1; // значения полей по умолчанию
```
Инициализация будет однократной. Если есть список инициализации, значения по умолчанию рассматриваться не будут.

```C++
Rational r; // в этой строке происходит инициализация по умолчанию
```

Если в классе нет ни одного конструктора, то конструктор по умолчанию есть, и данная строчка выполнится. Если добавить хоть один конструктор, это работать не будет. Нужно написать конструктор по умолчанию:
```C++
Rational()
{
}
```
Или же так:
```C++
Rational() = default;
```
`default` работает и для других методов, но только когда компилятор может автоматически сгенерировать этот метод. Конструктор по умолчанию один из них.

Деструктор это метод, который позволяет вставить свои действия в момент разрушения объекта.  
Он может быть только один и без аргументов:
```C++
~Rational() // такой синтаксис
{
 std::cout << "destroy"; 
}
```

Его тоже можно сгенерировать автоматически:
```C++
~Rational() = default;
```
Обычно писать это не нужно, так как компилятор и так его автоматически сгенерирует.

Но всё же может это пригодиться, когда дело дойдёт до динамического полиморфизма и виртуальных функций - есть смысл явно запросить генерацию деструктора, если хочется также сделать его виртуальным.

**Полный цикл жизни сложного типа:**  
* Память выделяется
* Инициализация (возможно запускается конструктор, определенный пользователем)
* В рамках инициализации инициализируются все подобъекты, связанные с базовыми классами, все поля класса
* Выполняется тело конструктора
* Объект живет
* Потом выполняется тело деструктора
* Разрушаются поля класса в порядке обратном порядку инициализации
* И затем то же самое с подобъектами базовых классов.

Инициализация полей происходит в порядке из объявления в классе. Порядок в списке инициализации игнорируется, поэтому если инициализация одного поля зависит от другого, важно следить за их порядком.

**Делегация конструктора:**  
Делегация конструктора, это когда делегирующий конструктор вызывает целевой конструктор и делает какие-то дополнительные действия:
```C++
Rational(const int a, const int b, const int c) 
  : Rational(a, b)
{
  std::cout << c;
}
```
В списке инициализации не может быть чего-то кроме вызова конструктора.


Если класс `B` наследуется от класса `A`, в качестве конструктора для объекта класса `B` хотелось бы вызывать уже написанный конструктор для класса `A`. По умолчанию конструкторы базовых классов не доступны для пользователей класса-наследника. Можно делегировать конструктор `A` в конструкторе класса `B`. А можно написать еще проще:   
```C++
using A::A;
```
Эта конструкция позволяет вытащить какие-то имена в текущую область для имен. Например из базового класса в класс наследник. 




```C++
Rational(const double a) : numerator(a)
```
Такие конструкторы участвуют в неявном преобразовании типов
Тогда в `main()` можно написать:
```C++
Rational r1;
r1->add(11);
```

Допустим, у нас еще есть один конструктор, который принимает `int`. И тогда при вызове `r1->add(11L)` возникнет ошибка, так как не понятно, какой конструктор вызывать.  
Если передать `11` типа `short`, тогда произойдет расширение типа и запустится конструктор с `int`.  Компилятор считает расширение лучше преобразования.

Решить проблему неоднозначности частично помогает `explicit`, если написать его перед конструктором:
```C++
explicit Rational(const double a) {...}
```
Для того чтобы он вызвался, нужно сделать это явно. То есть `r1->add(0.1)` не будет вызывать этот конструктор, и вызовет тот, что принимает `int`. А вот такой вызов `r1->add(Rational{0.1})` вызовет его. Если первый конструктор тоже пометить `explicit`, то снова вернемся к ситуации неоднозначности.  
`explicit` убирает сущность которой он приписан из цепочки неявных преобразований (не только конструктор таким может быть).  
Иногда советуют **все** конструкторы, которые можно вызвать с одним аргументом, делать `explicit`.  
Не делать этого стоит тогда, когда есть чёткое желание допустить соответствующее неявное преобразование.

```C++
double to_double() const {
  return static_cast<double>(numerator) / denominator
}

operator double () const { // нет типа возвращаемого значения, чтобы 2 раза
  return to_double();      // не писать double
}
```
Теперь будет работать неявное преобразование из `Rational` в `double`.

С неявными преобразованиями надо быть осторожнее, поэтому к оператору преобразования можем написать `explicit` (тогда не будет приводить к `double` неявно).  
С помощью оператора `static_cast` можем сделать это явно.

Для `rational` хотим преобразование в `bool`:
```C++
operator bool () const {
  return numerator != 0
}

void f(const int x) {
  std::cout << x;
}

Rational r1{1, 1};
f(r1); // выведет 1
```

Цепочка неявных преобразований может состоять из `3` этапов:
* стандартное
* пользовательское
* стандартное

Тут первый этап не интересен. Второй: `Rational->bool`. Третий: `bool->int`.

Как исправить?
```C++
if(!!r1) // not-not
{
  ... // так боролись с приведением
}     // от bool к другому типу неявного
```
С `C++11` можно так:  
Дописать к оператору преобразования в `bool` `explicit`, и тогда:
```C++
f(*r1); // не будет работать
if (*r1) { // будет работать
  std::cout << "non zero";
}
```

В `C++11` появилось специальное понятие: контекст приведения к `bool`.  
И этот контекст стандартом языка закреплен за некоторыми механизмами, в том числе в `if`, условном операторе в циклах и других конструкциях, где требуется только тип `bool`. Там разрешается неявное приведение типов.  
НЕ `explicit` приведение к `bool -> однозначно ошибка`. Если нужно приведение к числам, лучше сделать отдельный оператор.


**Идея копирования значений сложных типов:**
Как компилятор понимает, как произвести копирование? Копирование базовых типов в язык встроено. А сложные? Комбинации из базовых типов - тоже просто копировать.

```C++
struct A {
  const int & n;
};
```

**Конструктор:**
```C++
A(const A & other) : n(other.n) {}
```
Он работает корректно, нет проблем с объявлением ссылки без инициализации.

```C++
A a1, a2;
a1 = a2; // Компилятор не знает, что делать с ссылкой, оператор присваивания по умолчанию не сгенерируется, будет ошибка
```

Для `Rational`:
```C++
void operator = (const Rational & other) {
  numerator = other.numerator;
  denominator = other.denominator;
}
```
Это копирование компилятор может сам сгенерировать.

Операция копирования имеет `2` случая:
* Инициализация копирования. Для нее служит конструктор копирования
* Присваивание копирования. Оператор копирующего присваивания

У нашего оператора есть одна проблема.  
В общем случае можно писать:
```C++
a = b = c = d;
// a = (b = (c = d)) тут выполняется правая ассоциативность 
```

Исправить можно так:
```C++
Rational & operator = (const Rational & other)
{
  numerator = other.numerator;
  denominator =  other.denominator;
  return *this;
}
```

Например, следующие методы классов могут быть сгенерированы автоматически:
* Конструктор по умолчанию
* Конструктор копирования
* Оператор копирующего присваивания

Условие того, что компилятор может сгенерировать два последних, это наличие разумного копирования.

Конструктор копирования - не шаблонный, с одной ссылкой `lvalue` (правильный дизайн это константная ссылка).  
Оператор присваивания аналогичен.

**Конструктор перемещения:**
```C++
A(A && other)
  : n(other.n)
{}
```

**Оператор перемещающего присваивания:**
```C++
A & operator = (A && other)
{ return *this; }
```

Конструктор перемещения и оператор перемещающего присваивания могут быть сгенерированы компилятором автоматически, но условия на их генерацию сложнее.

**Итого. Какие методы компилятор может генерировать по умолчанию:**
* [Конструктор по умолчанию](https://en.cppreference.com/w/cpp/language/default_constructor)
* [Деструктор](https://en.cppreference.com/w/cpp/language/destructor)
* [Конструктор копирования](https://en.cppreference.com/w/cpp/language/copy_constructor)
* [Конструктор перемещения](https://en.cppreference.com/w/cpp/language/move_constructor)
* [Оператор копирующего присваивания](https://en.cppreference.com/w/cpp/language/copy_assignment)
* [Оператор перемещающего присваивания](https://en.cppreference.com/w/cpp/language/move_assignment)

Бывают случаи, когда генерация возможна, но компилятор не делает это неявно.

Есть случай, когда мы хотим пометить специальный метод как удаленный:
```C++
Rational() = delete; // запрещаем компилятору автоматически генерировать конструктор по умолчанию 

Rational(const Rational &) = delete; // запрещает операцию копирования
Rational & operator = (const Rational &) = delete;
```

**Ситуация с операторами сравнения:**  
До `C++20` операции сравнения можно было только написать вручную.  
Хорошей практикой является определять все логически связанные операции.  
Например, равенство и неравенство.

В `C++` `Nan (not a number)` ни с кем не сравним.  
Поэтому следующая функция может выдать `false`:
```C++
bool check(const double x)
{
    return x == x;
}
```

Операторы сравнения очень сложные, с ними существует много проблем.

В `C++20`:
```C++
auto operator <=> (const Rational & x) const {
  return numerator <=> x.numerator;
} // оператор универсального сравнения (космический корабль) 
```

Для пользовательского типа достаточно определить оператор равенства и универсального сравнения.  
Компилятор может сгенерировать их автоматически, но неявно он делать этого не будет, нужно запрашивать через `= default`.  
[Тут можно почитать про это подробнее.](https://en.cppreference.com/w/cpp/language/default_comparisons)

Компилятор не генерирует остальные операторы автоматически, он `r1 != r2` представит как `!(r1 == r2)`, `<`, `<=` и тд может выразить через `<=>`.

`delete` имеет смысл писать для конструкторов и операторов, для которых возможна автоматическая генерация.

Однако его можно приписывать к любым другим методам.  
`delete` может быть актуальным при перегрузках функций, когда хочется запретить какие-то неявные преобразования аргументов:  
```C++
void process(double);
void process(int) = delete;

process(0.1); // OK
process(1); // compilation error
```
