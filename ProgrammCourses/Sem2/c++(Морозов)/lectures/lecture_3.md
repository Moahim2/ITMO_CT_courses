# Лекция 3: Заголовочные файлы, единицы трансляции, препроцессор, макросы

### Что такое единица трансляции?

Единица трансляции состоит из файла реализации и всех заголовков, которые он содержит прямо или косвенно. Файлы
реализации обычно имеют расширение .cpp или .cxx. Файлы заголовков обычно имеют расширение .h или .hpp. Компилятор не
знает про то, что находится в других единицах трансляции. На выходе единицы трансляции выходит один объектный файл.

### Почему определение != объявление?

Объявление - это то, что даётся нам без тела, т.е. без определения. А определение задаёт как раз его реализационную
часть.

#### Примеры объявления:

```C++
int f(double);
class C;
enum class E;
extern int a;

struct S {
    static S s;
};

using T = int;
using std::cout;

template <class T>
int g();
template <>
int g<double>();

template <class T> class X;
template <> class X<int>; // всё до этой строчки - объявления

struct S {
    static const int x = 0; // declaration
};

const int S::x; // definition

int main(int argc, char **argv) {
    const int & x = S::x; // S::x is ODR-used
    return S::x; // S::x isn't ODR-used
}
```

### Что такое ODR?

**ODR** (*one definition rule*) - в одной единице трансляции допустимо лишь одно определение любой переменной, функции,
класса, enum или шаблона. Во всей программе допустимо лишь одно определение функции или переменной, которая
ODR-используется (иначе - UB).

### Можно ли делать когда-либо повторение одного определения?

Да - это можно делать для класса, enum, шаблона, если их определения будут идентичны.

### Зачем нужны заголовочные файлы?

Затем, чтобы не копировать код вручную, а давать эту задачу препроцессору.

### Когда работает ODR-использование?

* Объект ODR - используется, если его значение читается, записывается, его адрес берётся или с ним связывается ссылка (
  если это не константа)
* Функция ODR - используется, если она вызывается или её адрес берётся.

### Что такое `inline`?

`inline` - это ключевое слово для функции, которое позволяет компилятору подставить её тело в место вызова функции. Но
важная пометка, компилятор может и не сделать этого, т.е. оставить обычной функцией.

### Зачем стоит использовать `inline`?

Если программист хочет уменьшить кол-во вызовов данной функции и получить меньшее время работы программы.

### Когда стоит использовать `inline`?

* Если функция часто вызывается и имеет маленькое тело

### Когда не стоит использовать?

* Когда функция общается с потоком ввода и вывода информации
* Когда функция имеет в себе много кода
* Когда используется рекурсия

### Доп. информация

`inline` позволяет несколько раз одинаково определять функцию, если сделать несколько `inline` функций с разными определениями, то
это UB. Помимо случаев, когда мы сами указываем `inline` функцию, он может сам
за счёт каких-то правил стать `inline`.

#### Примеры с `inline` объектами, функциями:

```C++
inline void f() {
    // эта функция помечена inline
}

inline int x = 0; // этот объект помечен inline

struct S {
    bool empty() {
        return true; 
    } // Так как мы внутри определения структуры вставили определение метода, то он может стать inline, а может и нет
    
    friend bool operator == (const S & lhs, const S & rhs) {
        return true; 
    } // Свободная функция внутри тоже становится неявно inline 

    static constexpr double pi = 3.14; // constexpr неявно преобразует в inline
};
```

### Что такое Linkage?

Имя, обозначающее объект, ссылку, функцию, тип, шаблон, пространство имён или значение, может иметь **linkage** (
связывание)

* Внешнее связывание - имя в разных единицах трансляции ссылается на одну и ту же сущность.
* Внутреннее связывание - имя в любых областях видимости данной единицы трансляции ссылается на одну и ту же сущность.
* Отсутствие связывания - имя является локальным для своей области видимости.

#### Примеры отсутствия связывания:

* Локальные переменные без *extern* (об этом чуть позже)
* Локальные классы
* Иные имена, объявленные на уровне блока

#### Примеры внешнего связывания:

* Глобальные либо *inline*, либо не-*const* переменные
* Глобальные *inline* переменные
* Функции
* Классы
* Шаблоны

#### Примеры внутреннего связывания:

* Глобальные *const* (включая *constexpr*) не-*inline* переменные
* Члены анонимных *union*
* Сущности, объявленные в анонимном пространстве имён

### Явное назначение связывания

* extern - спецификатор объявления переменных, позволяющий явно задать внешнее связывание
* static - спецификатор определения глобальных переменных или функций, явно задающий внутреннее связывание

#### Примеры назначения связывания:

```C++
extern int x; // external, declaration
extern int y = 101; // external, definition
int z = 111; // external
static int u = -1; // internal
const int v = 9; // internal
static const int w = 3; // internal
inline const int s = 3; // external
extern const int t = 1; // external
```

### Настоятельная рекомендация!

В данном примере мы используем внутреннее связывание, что значит, мы не сможем получить доступ из других единиц
трансляции к этой. **То есть рекомендуется использовать анонимный namespace для таких целей**

```C++
namespace {
    void foo() {
        
    }
    
    int xxx = 0;
} // namespace

int main() {
    foo();
    return xxx;
}
```

Да! Можно задать всё через static и это тоже будет внутренним связыванием, но static используется ещё для других вещей,
поэтому лучше не лезьте

### Language linkage

Имена переменных и функций с внешним связыванием обладают свойством *language linkage*, что позволяет *экстернить*
соответствующие объекты в другие языки, но на данный момент можно это делать с **C++** и **C**

```C++
extern string-literal { ... };
extern string-literal declaration;
```

Где string-literal:

* "C++"
* "C"

# Этапы трансляции

### Основные этапы трансляции

1) Склейка строк через **\\**
2) Предварительная токенизация (комментарии, пробелы)
3) Препроцессор (Запускает рекурсивно запуск предыдущих шагов для включенных заголовков)
4) Склейка смежных строковых литералов (Например "hello" "world" превратится в "helloworld")
5) Компиляция
6) Компоновка

### Базовые токены

* Идентификаторы
* Числовые токены
* Символьные, строковые литералы и аргументы **#include**
* Операторы и символы пунктуации
* Другое

```C++
a+++++b; // a ++ ++ + b
a++ + ++b // a ++ + ++ b
1E+12 // OK - это сумма
0x1E+12 // bad - это не сумма
0x1e +12 // OK - это сумма 
```

### Комментарии

#### Примеры:

```C++
/* Comment */

/*
 * Multi-line comment
 */

// Single-line comment

//
//
// Fancy comment formatting
//
```

# Препроцессор

### Какие бывают директивы препроцессора

Обычно выглядят так: **# директива [аргументы]**. Она должна размещаться на одной строке, занимает всю строку. Возможные
директивы:

* define
* undef
* include
* if, ifdef, ifndef, else, elif, endif
* error
* pragma
* line

### Что такое pragma?

Чаще используется #pragma once - такая директива вставляет всё что внутри хедера один раз, даже если этот хедер
несколько раз был импортирован

### Что такое error?

**#error message** - эта директива завершает процесс компиляции с ошибкой. Часто используется для того, чтобы выдавать
ошибку на
неизвестном компиляторе.

#### Пример:

```C++
#if defined(__clang__)
// clang
#elif defined(__GNUC__) || defined(__GNUG__)
// gcc
#elif defined(_MSC_VER)
// MSVC
#else
# error "Unsupported compiler"
#endif
```

### Что такое line?

**#line lineno**
**#line lineno "filename"**

Эта директива присваивает начиная с места её использования строки начиная с *lineno* и присваивая код файлу *filename*.

### Условные директивы

#### Примеры:

```C++
#ifdef identifier
#ifndef identifier
#if expression
#elif expression
#else
#endif
```

### Условные директивы, конструкция

На этапе препроцессинга останется только один из *case'ов*

```C++
#ifdef / ifndef / if
// main case
#elif ...
// alternative case
...
#else
// else case
...
#endif
```

### Условные директивы, выражения

1) Подстановка макросов
2) Оператор defined id или defined(id) -> 1 или 0
3) Оператор __has_include(...) -> 1 или 0 (здесь проверяется доступность какого-то заголовочного файла)
4) Прочие идентификаторы -> 0 (кроме true/false)
5) Базовые токены -> токены
6) Вычисление выражения, как константного

#### Пример:

```C++
//#define FOO
//#define X 3 * 1 + 0
#if
!defined(F00)
std::cout << "First" << std::endl;
#elif
X == 3
std::cout << "Second" << std::endl;
#else
# ifndef
BAR
std::cout << "Third" << std::endl;
# endif
#endif
```

### Директива include

**#include < файл >** - *стандартные* или *глобальные* файлы\
**#include " файл "** - *локальные* файлы

Служит для того, чтобы работали заголовочные файлы

### Пример работы препроцессинга:

#### a.h

```C++
int max(int a, int b);
inline const double pi = 3.14;
```  

#### a.cpp

```C++
void f() {};
#include "a.h"
#include "a.h"
int x = max(10, 100);
```

#### a.i

```C++
void f() {}
int max(int a, int b);
inline const double pi = 3.14;
int max(int a, int b);
inline const double pi = 3.14;
int x = max(10, 100);
```

##### Как защититься от повторного включения?

1) "Include guards" (В хедере подключить #ifndef с отслеживанием header_name)
2) **#pragma once**

# Макросы

#### Примеры:

```C++
#define identifier
#define identifier replacement
#define identifier(parameters) replacement
#define identifier(parameters, ...) replacement
#define identifier(...) replacement
#undef identifier
```

В общем и целом, мы ищем identifier и заменяем на replacement. Простой пример, с которым используются макросы - это
сборка проект на разных платформах.
C помощью **#defined identifier** мы можем определять - задавал ли программист макрос с именем identifier (и не делал **
#undef**)

### Правило - нельзя заменять с помощью макросов ключевые слова

### Сложные макросы

```C++
#define MAX(a, b) a < b ? b : a
if (MAX(x, y) == 0) {
    ...
}
//
//    ↓
//
if (x < y ? y : x == 0) {
    ...
}
//
//    ↓ здесь произойдёт лажа, потому что приоритет операции == меньше, чем у тернарного оператора
//
if ((x < y) ? (y) : (x = 0)) {
    ...
}
```

### Ограничения макросов

#### Рекурсия запрещена

```C++
#define foo foo

foo
//
// ↓
//
foo
```

#### Вложенные вызовы разрешены

```C++
#define foo(x) x

foo(foo(foo(1)))
//
// ↓
//
1
```

### Этапы подстановки:

1) Определение мест вхождения параметров в строке замены и их первичная подстановка
2) Раскрытие параметров в местах их подстановки
3) В строке замены обрабатываются макросы (при этом явно запрещена рекурсия)

### Специальные операции подстановки

#### stringification (литерация)

**# a**, где a - параметр макроса; вместо подстановки значения, подставляется его строковое представление

```C++
#define show(a, b, c) #a #b #c

show(x, 10, "hello\n")
//
// ↓ подставились строковые значения + произошла склейка строк
//
"x10\"hello\\n\""
```

#### concatenation (склейка)

**##** между любыми двумя параметрами или между параметром и другим токеном, делает
конкатенацию результатов их подстановки

```C++
#define print(type) void print_ ## type (type x) { \
    ...                                                \
}

print(char)
//
// ↓
//
void print_char(char x) {
    ...
}
```

### Особенности stringification и concatenation

При этом **#** и **##** оказывает влияние на обработку параметров макросов: литерация или склейка производятся до
возможного раскрытия параметров.

```C++
#define foo ABC
#define concat(a) foo ## a

concat(__LINE__)
//
// ↓
//
foo__LINE__
```

### Обход особенности stringification и concatenation

#### Обход ранней обработки операций **#** и **##** можно двойным перенаправлением:

```C++
// stringification
#define
show(x) do_show(x) // сначала заменяется на do_show(x), причём в x подставляется параметр 123
#define
do_show(x)
#

a // здесь x уже будет параметром, соответственно его строковое представление "123"

show(__LINE__)
//
// ↓
//
"123"

// concatenation - здесь всё аналогично
#define
concat(a, b) do_concat(a, b)
#define
do_concat(a, b) a ## b

concat(0x, __LINE__)
//
// ↓
//
0x123
```

### Защита параметров макросов

Как мы видели раннее c MAX(a, b) = a < b ? b : a, у нас здесь мог сломаться приоритет операций, что плохо, но это можно
было легко обойти таким образом

```C++
#define MAX(a, b) (a) < (b) ? (b) : (a)
MAX(0, x & 0xFF)
//
// ↓
//
(0) < (x & 0xFF) ? (x & 0xFF) : (0)
```

### Защита места вставки

```C++
#define PRINT(a) std::cout << a; return 0а

int main(int argc, char ** argv) {
    if (argc > 3)
        PRINT(argc);
    else
        return 1;
}
//
// ↓
//
int main(int argc, char ** argv) {
    if (argc > 3)
        std::cout << a; 
    return 0; // очевидно, этот код не скомпилируется
    else
        return 1;
}
```

Как избегать подобных проблем? Вставлять места вставки в **do {...} while (false)**!

```C++
#define PRINT(a) do { std::cout << a; return 0; } while (false)

int main(int argc, char ** argv) {
    if (argc > 3)
        PRINT(argc);
    else
        return 1;
}
//
// ↓ 
//
int main(int argc, char ** argv) {
    if (argc > 3)
        do { std::cout << a; return 0; } while (false);
    else
        return 1;
}
```

### Побочные эффекты в макросах

```C++
#define MAX(a, b) (a) < (b) ? (b) : (a)

MAX(x++, --y);
//
// ↓ 
//
(x++) < (--y) < (--y) : (x++);
```

С этим уже никак не побороться, придётся смириться

### Какое свойство макросов нельзя заменить другим элементами языка?

Возможность формирования токена языка (Альтернативно - внешний кодогенератор, но гораздо проще написать с помощью
макросов)

# Пример из лекции про торговую площадку на бирже. [Ссылка](https://www.youtube.com/watch?v=ojFlaV9exPs&t=2809s)